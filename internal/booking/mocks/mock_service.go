// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/booking/service.go
//
// Generated by this command:
//
//	mockgen -package mocks -destination ./internal/booking/mocks/mock_service.go -source ./internal/booking/service.go
//

// Package mocks is a generated GoMock package.
package mocks

import (
	workplace "geektrust/internal/workplace"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockBooker is a mock of Booker interface.
type MockBooker struct {
	ctrl     *gomock.Controller
	recorder *MockBookerMockRecorder
}

// MockBookerMockRecorder is the mock recorder for MockBooker.
type MockBookerMockRecorder struct {
	mock *MockBooker
}

// NewMockBooker creates a new mock instance.
func NewMockBooker(ctrl *gomock.Controller) *MockBooker {
	mock := &MockBooker{ctrl: ctrl}
	mock.recorder = &MockBookerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBooker) EXPECT() *MockBookerMockRecorder {
	return m.recorder
}

// Book mocks base method.
func (m *MockBooker) Book(arg0 workplace.Period, arg1 workplace.NumOfPeople) (workplace.Reservation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Book", arg0, arg1)
	ret0, _ := ret[0].(workplace.Reservation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Book indicates an expected call of Book.
func (mr *MockBookerMockRecorder) Book(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Book", reflect.TypeOf((*MockBooker)(nil).Book), arg0, arg1)
}

// MockRoomsAvailabler is a mock of RoomsAvailabler interface.
type MockRoomsAvailabler struct {
	ctrl     *gomock.Controller
	recorder *MockRoomsAvailablerMockRecorder
}

// MockRoomsAvailablerMockRecorder is the mock recorder for MockRoomsAvailabler.
type MockRoomsAvailablerMockRecorder struct {
	mock *MockRoomsAvailabler
}

// NewMockRoomsAvailabler creates a new mock instance.
func NewMockRoomsAvailabler(ctrl *gomock.Controller) *MockRoomsAvailabler {
	mock := &MockRoomsAvailabler{ctrl: ctrl}
	mock.recorder = &MockRoomsAvailablerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRoomsAvailabler) EXPECT() *MockRoomsAvailablerMockRecorder {
	return m.recorder
}

// RoomsAvailable mocks base method.
func (m *MockRoomsAvailabler) RoomsAvailable(arg0 workplace.Period) []workplace.Vacancy {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RoomsAvailable", arg0)
	ret0, _ := ret[0].([]workplace.Vacancy)
	return ret0
}

// RoomsAvailable indicates an expected call of RoomsAvailable.
func (mr *MockRoomsAvailablerMockRecorder) RoomsAvailable(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RoomsAvailable", reflect.TypeOf((*MockRoomsAvailabler)(nil).RoomsAvailable), arg0)
}
